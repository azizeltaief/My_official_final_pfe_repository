{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\azize\\\\OneDrive\\\\Bureau\\\\internship\\\\learning\\\\MERN_Web - Copie\\\\frontend\\\\src\\\\context\\\\UserContext.js\",\n  _s = $RefreshSig$();\n//in this file we gonna make a context and a context provider component\nimport { createContext, useReducer } from \"react\"; //import this fct that let us create a context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const UserContext = /*#__PURE__*/createContext(); //create a context and store it in this variable,this create us a context and then we export it to use it\n\nexport const userReducer = (state, action) => {\n  //2arguments,state:theprevios satet before we made the change,action that has type and payload properties of the object passed as an argument to the dispatch fct\n\n  switch (action.type) {\n    //this is all with the local state we aren't interacting with the db just to made the local state insync with the db\n    case 'SET_USERS':\n      //in each case we wanna return the new value of the state.\n      return {\n        users: action.payload //WE WILL RETURN AN OBJECT THAT HAS A SCRIPT PROPERTY,because in this case the payload property of the action that we pass into the dispatch fct gonna be an array of all the scripts.\n      };\n    case 'CREATE_USER':\n      return {\n        users: [action.payload, ...state.users] //WE WILL RETURN A NEW ARRAY,...state.scripts will be an array of the preexisting scripts + action.payload which is the new added(to the top) script =>the final array\n      };\n    case 'DELETE_USER':\n      return {\n        users: state.users.filter(user => user._id !== action.payload._id)\n      };\n    default:\n      return state;\n  }\n};\nexport const UserContextProvider = ({\n  children\n}) => {\n  _s();\n  const [state, dispatch] = useReducer(userReducer, {\n    users: null\n  });\n  return /*#__PURE__*/_jsxDEV(UserContext.Provider, {\n    value: {\n      ...state,\n      dispatch\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 40,\n    columnNumber: 5\n  }, this);\n};\n_s(UserContextProvider, \"4ntA4J59rHNQOjQrreIw5y2jyBU=\");\n_c = UserContextProvider;\nvar _c;\n$RefreshReg$(_c, \"UserContextProvider\");","map":{"version":3,"names":["createContext","useReducer","jsxDEV","_jsxDEV","UserContext","userReducer","state","action","type","users","payload","filter","user","_id","UserContextProvider","children","_s","dispatch","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/azize/OneDrive/Bureau/internship/learning/MERN_Web - Copie/frontend/src/context/UserContext.js"],"sourcesContent":["\r\n//in this file we gonna make a context and a context provider component\r\nimport { createContext, useReducer } from \"react\"; //import this fct that let us create a context\r\n\r\nexport const UserContext = createContext() //create a context and store it in this variable,this create us a context and then we export it to use it\r\n\r\nexport const userReducer = (state,action) =>{  //2arguments,state:theprevios satet before we made the change,action that has type and payload properties of the object passed as an argument to the dispatch fct\r\n\r\n  switch(action.type){\r\n    //this is all with the local state we aren't interacting with the db just to made the local state insync with the db\r\n    case 'SET_USERS': //in each case we wanna return the new value of the state.\r\n      return { \r\n        users: action.payload   //WE WILL RETURN AN OBJECT THAT HAS A SCRIPT PROPERTY,because in this case the payload property of the action that we pass into the dispatch fct gonna be an array of all the scripts.\r\n      }\r\n    case 'CREATE_USER':\r\n      return {\r\n        users : [action.payload, ...state.users] //WE WILL RETURN A NEW ARRAY,...state.scripts will be an array of the preexisting scripts + action.payload which is the new added(to the top) script =>the final array\r\n      }\r\n    case 'DELETE_USER':\r\n      return{\r\n        users: state.users.filter(user => user._id !== action.payload._id)\r\n      }\r\n    default:\r\n      return state\r\n      \r\n  }\r\n}\r\n\r\n\r\n\r\nexport const UserContextProvider = ({children}) =>{\r\n\r\n  const [state,dispatch] = useReducer(userReducer,{\r\n    users:null\r\n  })\r\n\r\n \r\n\r\n  return(\r\n    <UserContext.Provider value={{...state,dispatch}}>  \r\n        {children}   \r\n    </UserContext.Provider>\r\n  \r\n  )\r\n}"],"mappings":";;AACA;AACA,SAASA,aAAa,EAAEC,UAAU,QAAQ,OAAO,CAAC,CAAC;AAAA,SAAAC,MAAA,IAAAC,OAAA;AAEnD,OAAO,MAAMC,WAAW,gBAAGJ,aAAa,CAAC,CAAC,EAAC;;AAE3C,OAAO,MAAMK,WAAW,GAAGA,CAACC,KAAK,EAACC,MAAM,KAAI;EAAG;;EAE7C,QAAOA,MAAM,CAACC,IAAI;IAChB;IACA,KAAK,WAAW;MAAE;MAChB,OAAO;QACLC,KAAK,EAAEF,MAAM,CAACG,OAAO,CAAG;MAC1B,CAAC;IACH,KAAK,aAAa;MAChB,OAAO;QACLD,KAAK,EAAG,CAACF,MAAM,CAACG,OAAO,EAAE,GAAGJ,KAAK,CAACG,KAAK,CAAC,CAAC;MAC3C,CAAC;IACH,KAAK,aAAa;MAChB,OAAM;QACJA,KAAK,EAAEH,KAAK,CAACG,KAAK,CAACE,MAAM,CAACC,IAAI,IAAIA,IAAI,CAACC,GAAG,KAAKN,MAAM,CAACG,OAAO,CAACG,GAAG;MACnE,CAAC;IACH;MACE,OAAOP,KAAK;EAEhB;AACF,CAAC;AAID,OAAO,MAAMQ,mBAAmB,GAAGA,CAAC;EAACC;AAAQ,CAAC,KAAI;EAAAC,EAAA;EAEhD,MAAM,CAACV,KAAK,EAACW,QAAQ,CAAC,GAAGhB,UAAU,CAACI,WAAW,EAAC;IAC9CI,KAAK,EAAC;EACR,CAAC,CAAC;EAIF,oBACEN,OAAA,CAACC,WAAW,CAACc,QAAQ;IAACC,KAAK,EAAE;MAAC,GAAGb,KAAK;MAACW;IAAQ,CAAE;IAAAF,QAAA,EAC5CA;EAAQ;IAAAK,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACS,CAAC;AAG3B,CAAC;AAAAP,EAAA,CAdYF,mBAAmB;AAAAU,EAAA,GAAnBV,mBAAmB;AAAA,IAAAU,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}