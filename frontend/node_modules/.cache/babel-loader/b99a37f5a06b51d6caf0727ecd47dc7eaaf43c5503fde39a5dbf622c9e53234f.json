{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = deleteUnknownAutoBindMethods;\nfunction shouldDeleteClassicInstanceMethod(component, name) {\n  if (component.__reactAutoBindMap && component.__reactAutoBindMap.hasOwnProperty(name)) {\n    // It's a known autobound function, keep it\n    return false;\n  }\n  if (component.__reactAutoBindPairs && component.__reactAutoBindPairs.indexOf(name) >= 0) {\n    // It's a known autobound function, keep it\n    return false;\n  }\n  if (component[name].__reactBoundArguments !== null) {\n    // It's a function bound to specific args, keep it\n    return false;\n  }\n\n  // It's a cached bound method for a function\n  // that was deleted by user, so we delete it from component.\n  return true;\n}\nfunction shouldDeleteModernInstanceMethod(component, name) {\n  var prototype = component.constructor.prototype;\n  var prototypeDescriptor = Object.getOwnPropertyDescriptor(prototype, name);\n  if (!prototypeDescriptor || !prototypeDescriptor.get) {\n    // This is definitely not an autobinding getter\n    return false;\n  }\n  if (prototypeDescriptor.get().length !== component[name].length) {\n    // The length doesn't match, bail out\n    return false;\n  }\n\n  // This seems like a method bound using an autobinding getter on the prototype\n  // Hopefully we won't run into too many false positives.\n  return true;\n}\nfunction shouldDeleteInstanceMethod(component, name) {\n  var descriptor = Object.getOwnPropertyDescriptor(component, name);\n  if (typeof descriptor.value !== 'function') {\n    // Not a function, or something fancy: bail out\n    return;\n  }\n  if (component.__reactAutoBindMap || component.__reactAutoBindPairs) {\n    // Classic\n    return shouldDeleteClassicInstanceMethod(component, name);\n  } else {\n    // Modern\n    return shouldDeleteModernInstanceMethod(component, name);\n  }\n}\n\n/**\n * Deletes autobound methods from the instance.\n *\n * For classic React classes, we only delete the methods that no longer exist in map.\n * This means the user actually deleted them in code.\n *\n * For modern classes, we delete methods that exist on prototype with the same length,\n * and which have getters on prototype, but are normal values on the instance.\n * This is usually an indication that an autobinding decorator is being used,\n * and the getter will re-generate the memoized handler on next access.\n */\nfunction deleteUnknownAutoBindMethods(component) {\n  var names = Object.getOwnPropertyNames(component);\n  names.forEach(function (name) {\n    if (shouldDeleteInstanceMethod(component, name)) {\n      delete component[name];\n    }\n  });\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","deleteUnknownAutoBindMethods","shouldDeleteClassicInstanceMethod","component","name","__reactAutoBindMap","hasOwnProperty","__reactAutoBindPairs","indexOf","__reactBoundArguments","shouldDeleteModernInstanceMethod","prototype","constructor","prototypeDescriptor","getOwnPropertyDescriptor","get","length","shouldDeleteInstanceMethod","descriptor","names","getOwnPropertyNames","forEach"],"sources":["C:/Users/azize/OneDrive/Bureau/internship/learning/MERN_Web - Copie/frontend/node_modules/react-proxy/modules/deleteUnknownAutoBindMethods.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = deleteUnknownAutoBindMethods;\nfunction shouldDeleteClassicInstanceMethod(component, name) {\n  if (component.__reactAutoBindMap && component.__reactAutoBindMap.hasOwnProperty(name)) {\n    // It's a known autobound function, keep it\n    return false;\n  }\n\n  if (component.__reactAutoBindPairs && component.__reactAutoBindPairs.indexOf(name) >= 0) {\n    // It's a known autobound function, keep it\n    return false;\n  }\n\n  if (component[name].__reactBoundArguments !== null) {\n    // It's a function bound to specific args, keep it\n    return false;\n  }\n\n  // It's a cached bound method for a function\n  // that was deleted by user, so we delete it from component.\n  return true;\n}\n\nfunction shouldDeleteModernInstanceMethod(component, name) {\n  var prototype = component.constructor.prototype;\n\n  var prototypeDescriptor = Object.getOwnPropertyDescriptor(prototype, name);\n\n  if (!prototypeDescriptor || !prototypeDescriptor.get) {\n    // This is definitely not an autobinding getter\n    return false;\n  }\n\n  if (prototypeDescriptor.get().length !== component[name].length) {\n    // The length doesn't match, bail out\n    return false;\n  }\n\n  // This seems like a method bound using an autobinding getter on the prototype\n  // Hopefully we won't run into too many false positives.\n  return true;\n}\n\nfunction shouldDeleteInstanceMethod(component, name) {\n  var descriptor = Object.getOwnPropertyDescriptor(component, name);\n  if (typeof descriptor.value !== 'function') {\n    // Not a function, or something fancy: bail out\n    return;\n  }\n\n  if (component.__reactAutoBindMap || component.__reactAutoBindPairs) {\n    // Classic\n    return shouldDeleteClassicInstanceMethod(component, name);\n  } else {\n    // Modern\n    return shouldDeleteModernInstanceMethod(component, name);\n  }\n}\n\n/**\n * Deletes autobound methods from the instance.\n *\n * For classic React classes, we only delete the methods that no longer exist in map.\n * This means the user actually deleted them in code.\n *\n * For modern classes, we delete methods that exist on prototype with the same length,\n * and which have getters on prototype, but are normal values on the instance.\n * This is usually an indication that an autobinding decorator is being used,\n * and the getter will re-generate the memoized handler on next access.\n */\nfunction deleteUnknownAutoBindMethods(component) {\n  var names = Object.getOwnPropertyNames(component);\n\n  names.forEach(function (name) {\n    if (shouldDeleteInstanceMethod(component, name)) {\n      delete component[name];\n    }\n  });\n}"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,OAAO,GAAGC,4BAA4B;AAC9C,SAASC,iCAAiCA,CAACC,SAAS,EAAEC,IAAI,EAAE;EAC1D,IAAID,SAAS,CAACE,kBAAkB,IAAIF,SAAS,CAACE,kBAAkB,CAACC,cAAc,CAACF,IAAI,CAAC,EAAE;IACrF;IACA,OAAO,KAAK;EACd;EAEA,IAAID,SAAS,CAACI,oBAAoB,IAAIJ,SAAS,CAACI,oBAAoB,CAACC,OAAO,CAACJ,IAAI,CAAC,IAAI,CAAC,EAAE;IACvF;IACA,OAAO,KAAK;EACd;EAEA,IAAID,SAAS,CAACC,IAAI,CAAC,CAACK,qBAAqB,KAAK,IAAI,EAAE;IAClD;IACA,OAAO,KAAK;EACd;;EAEA;EACA;EACA,OAAO,IAAI;AACb;AAEA,SAASC,gCAAgCA,CAACP,SAAS,EAAEC,IAAI,EAAE;EACzD,IAAIO,SAAS,GAAGR,SAAS,CAACS,WAAW,CAACD,SAAS;EAE/C,IAAIE,mBAAmB,GAAGjB,MAAM,CAACkB,wBAAwB,CAACH,SAAS,EAAEP,IAAI,CAAC;EAE1E,IAAI,CAACS,mBAAmB,IAAI,CAACA,mBAAmB,CAACE,GAAG,EAAE;IACpD;IACA,OAAO,KAAK;EACd;EAEA,IAAIF,mBAAmB,CAACE,GAAG,CAAC,CAAC,CAACC,MAAM,KAAKb,SAAS,CAACC,IAAI,CAAC,CAACY,MAAM,EAAE;IAC/D;IACA,OAAO,KAAK;EACd;;EAEA;EACA;EACA,OAAO,IAAI;AACb;AAEA,SAASC,0BAA0BA,CAACd,SAAS,EAAEC,IAAI,EAAE;EACnD,IAAIc,UAAU,GAAGtB,MAAM,CAACkB,wBAAwB,CAACX,SAAS,EAAEC,IAAI,CAAC;EACjE,IAAI,OAAOc,UAAU,CAACnB,KAAK,KAAK,UAAU,EAAE;IAC1C;IACA;EACF;EAEA,IAAII,SAAS,CAACE,kBAAkB,IAAIF,SAAS,CAACI,oBAAoB,EAAE;IAClE;IACA,OAAOL,iCAAiC,CAACC,SAAS,EAAEC,IAAI,CAAC;EAC3D,CAAC,MAAM;IACL;IACA,OAAOM,gCAAgC,CAACP,SAAS,EAAEC,IAAI,CAAC;EAC1D;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASH,4BAA4BA,CAACE,SAAS,EAAE;EAC/C,IAAIgB,KAAK,GAAGvB,MAAM,CAACwB,mBAAmB,CAACjB,SAAS,CAAC;EAEjDgB,KAAK,CAACE,OAAO,CAAC,UAAUjB,IAAI,EAAE;IAC5B,IAAIa,0BAA0B,CAACd,SAAS,EAAEC,IAAI,CAAC,EAAE;MAC/C,OAAOD,SAAS,CAACC,IAAI,CAAC;IACxB;EACF,CAAC,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}